# -*- coding: utf-8 -*-
"""Untitled2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TGkXKYetI6ketMssosefc3HVRPrERNBb
"""

def f(n):
    x = 1
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            x = x + 1
    return x

f(5)

"""1. Find the runtime of the algorithm mathematically.


$T(n)=1+\sum_{i=1}^{n+1}1+\sum_{i=1}^{n}\sum_{j=1}^{n+1}1+\sum_{i=1}^{n}\sum_{j=1}^{n} 1\\ =1+(n+1)+n(n+1)+n^2\\
=2n^2+2n+2$

2. Time this function for various n e.g. n = 1,2,3.... You should have small values of n all the way up to large values. Plot "time" vs "n" (time on y-axis and n on x-axis). Also, fit a curve to your data, hint it's a polynomial.
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

def f(n):
    x = 1
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            x = x + 1
    return x

# Values of n to test
n_values = [1,2,4,10, 50, 100, 200, 300]

# Time taken for each value of n
execution_times = []

for n in n_values:
    # Time the execution of f(n)
    execution_time = timeit.timeit(lambda: f(n), number=1)
    execution_times.append(execution_time)

# Plotting time vs n
plt.plot(n_values, execution_times, marker='o', label='Execution Time')

# Fit curve to the data
def func(n, a, b):
    return a * np.power(n, b)

popt, pcov = curve_fit(func, n_values, execution_times)
plt.plot(n_values, func(np.array(n_values), *popt), label='Fit: a=%5.3f, b=%5.3f' % tuple(popt))

plt.title('Execution Time vs Value of n with Curve Fit')
plt.xlabel('Value of n')
plt.ylabel('Execution Time (seconds)')
plt.legend()
plt.grid(True)
plt.show()

"""3. Find polynomials that are upper and lower bounds on your curve from #2. From this specify a big-O, a big-Omega, and what big-theta is."""

# Plotting time vs n
plt.plot(n_values, execution_times, marker='o', label='Execution Time')

# Plot the fitted curve
plt.plot(n_values, func(np.array(n_values), *popt), label='Fitted Curve')

# Plot upper and lower bounds
upper_bound = 0.000001 * np.power(n_values, 1.53)
lower_bound = 0.000001 * np.power(n_values, 1.4)
plt.plot(n_values, upper_bound, label='Upper Bound', linestyle='--')
plt.plot(n_values, lower_bound, label='Lower Bound', linestyle='--')
plt.title('Execution Time vs Value of n with Bounds')
plt.xlabel('Value of n')
plt.ylabel('Execution Time (seconds)')
plt.legend()
plt.grid(True)
plt.show()

"""4. Find the approximate (eye ball it) location of "n_0" . Do this by zooming in on your plot and indicating on the plot where n_0 is and why you picked this value. Hint: I should see data that does not follow the trend of the polynomial you determined in #2."""

# Plotting time vs n
plt.plot(n_values, execution_times, marker='o', label='Execution Time')

# Plot the fitted curve
plt.plot(n_values, func(np.array(n_values), *popt), label='Fitted Curve')

# Plot upper and lower bounds
upper_bound = 0.000001 * np.power(n_values, 1.53)
lower_bound = 0.000001 * np.power(n_values, 1.4)
plt.plot(n_values, upper_bound, label='Upper Bound', linestyle='--')
plt.plot(n_values, lower_bound, label='Lower Bound', linestyle='--')
plt.title('Execution Time vs Value of n with Bounds')
plt.xlabel('Value of n')
plt.ylabel('Execution Time (seconds)')
plt.legend()
plt.grid(True)
# Set limits for x and y axes to zoom in
plt.xlim(0, 5)  # Adjust xmin and xmax as needed
plt.ylim(0, 0.00001)  # Adjust ymin and ymax as needed

plt.show()

"""Take $n_0=3$  since after 3 it follows the trend."""

def f(n):
    x = 1
    y = 1
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            x = x + 1
            y = i + j
    return x, y

f(5)

"""5. Will this increate how long it takes the algorithm to run (e.x. you are timing the function like in #2)?

Yes, modifying the function will increase the time because the inner loop: y = i + j. This computation will add extra time to each iteration of the inner loop. As a result, the overall time taken to execute the function will increase compared to the original function.

6. Will it effect your results from #1?

Yes, it will be
$$T(n)=2+\sum_{i=1}^{n+1}1+\sum_{i=1}^{n}\sum_{j=1}^{n+1}1+\sum_{i=1}^{n}\sum_{j=1}^{n} 1+\sum_{i=1}^{n}\sum_{j=1}^{n} 1\\ =2+(n+1)+n(n+1)+2n^2\\
=3n^2+2n+3$$
"""